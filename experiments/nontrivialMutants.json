[
  {
    "ruleNr": 1,
    "rule": "<Expr> + <Expr> -> <Expr> - <Expr> (replace + operator in binary expression with -)\nNote: The rule only applies to \"+\"-expressions. The rewritten expression should contain \"-\" instead.\n",
    "originalCode": "result[country].all.push(id);",
    "rewrittenCode": "result[country].all.subtract(id);",
    "lineApplied": 35,
    "occursInSourceCode": false,
    "isTrivialRewrite": false
  },
  {
    "ruleNr": 2,
    "rule": "<Expr> === <Expr> -> <Expr> !== <Expr> (replace === operator in condition with !==)\nNote: The rule only applies to \"===\"-expressions. The rewritten expression should contain \"!==\" instead.\n",
    "originalCode": "if (tz.r === undefined) result[country].current.push(id);",
    "rewrittenCode": "if (tz.r !== undefined) result[country].current.push(id);",
    "lineApplied": 34,
    "occursInSourceCode": false,
    "isTrivialRewrite": false
  },
  {
    "ruleNr": 2,
    "rule": "<Expr> === <Expr> -> <Expr> !== <Expr> (replace === operator in condition with !==)\nNote: The rule only applies to \"===\"-expressions. The rewritten expression should contain \"!==\" instead.\n",
    "originalCode": "if (tz.r === undefined) result[country].current.push(id);",
    "rewrittenCode": "if (tz.r !== undefined) result[country].current.push(id);",
    "lineApplied": 33,
    "occursInSourceCode": true,
    "isTrivialRewrite": false
  },
  {
    "ruleNr": 3,
    "rule": "<Expr> !== <Expr> -> <Expr> === <Expr> (replace !== operator in condition with ===)\nNote: The rule only applies to \"!==\"-expressions. The rewritten expression should contain \"===\" instead.\n",
    "originalCode": "if (tz.r === undefined) result[country].current.push(id);",
    "rewrittenCode": "if (tz.r === undefined) result[country].current.push(id);",
    "lineApplied": 34,
    "occursInSourceCode": false,
    "isTrivialRewrite": true
  },
  {
    "ruleNr": 4,
    "rule": "<Expr> || {} -> <Expr> (replace binary || expression with its first operand if the second operand is an empty object literal)\nNote: The rule applies only to \"||\"-expressions. The rewritten expression should not contain \"{}\" anymore.\n",
    "originalCode": "getTimezonesMap(data)[id] || {}",
    "rewrittenCode": "getTimezonesMap(data)[id]",
    "lineApplied": 7,
    "occursInSourceCode": true,
    "isTrivialRewrite": false
  },
  {
    "ruleNr": 4,
    "rule": "<Expr> || {} -> <Expr> (replace binary || expression with its first operand if the second operand is an empty object literal)\nNote: The rule applies only to \"||\"-expressions. The rewritten expression should not contain \"{}\" anymore.\n",
    "originalCode": "allTimezones: tzMap.all || [],",
    "rewrittenCode": "allTimezones: tzMap.all,",
    "lineApplied": 13,
    "occursInSourceCode": true,
    "isTrivialRewrite": false
  },
  {
    "ruleNr": 4,
    "rule": "<Expr> || {} -> <Expr> (replace binary || expression with its first operand if the second operand is an empty object literal)\nNote: The rule applies only to \"||\"-expressions. The rewritten expression should not contain \"{}\" anymore.\n",
    "originalCode": "const aliasTz = data.timezones[a] || {};",
    "rewrittenCode": "const aliasTz = data.timezones[a];",
    "lineApplied": 26,
    "occursInSourceCode": true,
    "isTrivialRewrite": false
  },
  {
    "ruleNr": 5,
    "rule": "return <Expr>; -> return !<Expr>; (negate expression, but ONLY in a return statement)\nNote: The rule only applies to return statements. The rewritten expression should contain \"!\".\n",
    "originalCode": "return {};",
    "rewrittenCode": "return !{};",
    "lineApplied": 38,
    "occursInSourceCode": false,
    "isTrivialRewrite": false
  },
  {
    "ruleNr": 5,
    "rule": "return <Expr>; -> return !<Expr>; (negate expression, but ONLY in a return statement)\nNote: The rule only applies to return statements. The rewritten expression should contain \"!\".\n",
    "originalCode": "return result;",
    "rewrittenCode": "return !result;",
    "lineApplied": 38,
    "occursInSourceCode": false,
    "isTrivialRewrite": false
  }
]